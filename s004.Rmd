# Wrangle yo' data

## Announcements

### Comments on assignments

- Great job overall!
- Add `keep_md: TRUE` to the `html_document` output parameters in you `.Rmd` files
<!-- - From Assignment 2 onwards, whenever you produce an HTML file, you must link to a rendered version of the file. We'll cover this today. -->

__Worksheet__: You can find the worksheet template for today [here](https://raw.githubusercontent.com/USF-Psych-DataSci/Classroom/master/tutorials/s04_data-wrangling-exercise.Rmd).


## Today's Topics

Today we'll get started with learning to "wrangle" dataâ€”that is, to subset it, rearrange it, 
transform it, and otherwise make it ready for analysis. We are going to be working with the 
[`dplyr`](https://dplyr.tidyverse.org/) package. Specifically, we're going to consider three
lessons today:

- Intro to `dplyr` syntax
- The `%>%` pipe and the `dplyr` advantage
- `filter`; relational/comparison and logical operators in R

- Specific `dplyr` functions we will cover
  - [ ] `select()`
  - [ ] `arrange()`
  - [ ] `filter()`
  - [ ] `mutate()`
  - [ ] `summarize()`
  - [ ] `group_by()`
      - [ ] grouped `mutate()`
      - [ ] grouped `summarize()`
- _Maybe:_ `tsibble` and `lubridate` 
<!-- - Time dependent: GitHub pages -->


## Resources

STAT 545 chapters:
  - [stat545: dplyr-intro](http://stat545.com/block009_dplyr-intro.html)
  - [stat545: dplyr-single](https://stat545.com/dplyr-single.html)

More detail can be found in the [r4ds: transform](http://r4ds.had.co.nz/transform.html) chapter.

Here are some supplementary resources:

- A similar resource to the r4ds one above is the [intro to dplyr vignette](https://cran.r-project.org/web/packages/dplyr/vignettes/dplyr.html).
- Want to read more about piping? See [r4ds: pipes](http://r4ds.had.co.nz/pipes.html).

Some advanced topics you might find useful:
- For window functions and how dplyr handles them, see the [window-functions](https://cran.r-project.org/web/packages/dplyr/vignettes/window-functions.html) vignette for the `dplyr` package. 
- For time series data, see the [tsibble demo](https://tsibble.tidyverts.org/)


## Participation

To get participation points for today, you will need to:
  - Make a new folder in your participation repo called `wrangling`
  - Fill out the worksheet, knit it, and push the files to this folder:
    - [s04_data-wrangling-exercise.Rmd](https://raw.githubusercontent.com/USF-Psych-DataSci/Classroom/master/tutorials/s04_data-wrangling-exercise.Rmd).


## Intro to `dplyr` syntax

### Learning Objectives

Here are the concepts we'll be exploring in this lesson:

- tidyverse
- `dplyr` functions:
    - select
    - arrange
- piping

By the end of this lesson, students are expected to be able to:

- subset and rearrange data with `dplyr`
- use piping (`%>%`) when implementing function chains

### Preamble

Let's talk about:

- The history of `dplyr`: `plyr`
  - Don't use both in one script!
  - My recommendation, don't use `plyr` at all at this point.
- tibbles are a special type of data frame
- the [tidyverse](https://www.tidyverse.org/)

### Demonstration

Let's get started with the exercise:

1. Open RStudio, and download the `tidyverse` meta-package by executing `install.packages("tidyverse")` into the R console.
2. _Optional_: open the `STAT545_participation` RStudio project in RStudio.
3. With RStudio, open the `cm006-exercise.Rmd` file you downloaded and committed earlier.
4. Follow the instructions in the `.Rmd` file until the *Resume Lecture* section.


## Small break

Here are some things you might choose to do on this break:

- Talk with a TA, Vincenzo, or your neighbour(s) about the content so far.
- Attempt the bonus exercises on the `cm006-exercise.Rmd` file.
- Work on an assignment.


## The `dplyr` advantage

### Learning Objectives

By the end of this lesson, you will:

- Have a sense of why `dplyr` is advantageous compared to the "base R" way with respect to good coding practice.

Why?

- Having this in the back of your mind will help you identify qualities of and produce a readable analysis.

### Compare base R to `dplyr`

__Self-documenting code__. 

This is where the tidyverse shines.

Example of `dplyr` vs base R:

```
gapminder[gapminder$country == "Cambodia", c("year", "lifeExp")]
```

vs.

```
gapminder %>%
  filter(country == "Cambodia") %>%
  select(year, lifeExp)
```

![Morning Routine Pipie](https://raw.githubusercontent.com/USF-Psych-DataSci/Classroom/master/img/pipe_routine.jpg)

### The workflow:

1. Wrangle your data with `dplyr` first
2. Pipe `%>%` your data into a plot/analysis

### Basic principles:

1. Do one thing at a time
  - Transform variables OR select variables OR filter cases
2. Chain multiple operations together using the pipe `%>%` 
3. Use readable object and variable names
4. Subset a dataset (i.e., select variables) by **name**, not by "magic numbers"
5. _Note that you need to use the assignment operator `<-` to store changes!_

### Tangent: Base R workflow

- We are jumping right into the tidyverse way of doing things in R, instead of the base R way of doing things. Our first week was about "just enough" base R to get you started. If you feel that you want more practice here, take a look at [the R intro stat videos by MarinStatsLectures](https://www.youtube.com/playlist?list=PLqzoL9-eJTNARFXxgwbqGo56NtbJnB37A).


## Relational/Comparison and Logical Operators in R

### Learning Objectives

Here are the concepts we'll be exploring in this lesson:

- Relational/comparison operators
- Logical operators
- `dplyr` functions:
    - filter
    - mutate

By the end of this lesson, students are expected to be able to:

- Predict the output of R code containing the above operators.
- Explain the difference between `&`/`&&` and `|`/`||`, and name a situation 
  where one should be used over the other.
- Subsetting and transforming data using filter and mutate

### R Operators

**Arithmetic** operators allow us to carry out mathematical operations:

| Operator | Description |
|------|:---------|
| + | Add |
| - | Subtract |
| * | Multiply |
| / | Divide |
| ^ | Exponent |
| %/% | Integer division |
| %% | Modulus (remainder from integer division) |

**Relational** operators allow us to compare values:

| Operator | Description |
|------|:---------|
| < | Less than |
| > | Greater than |
| <= | Less than or equal to |
| >= | Greater than or equal to |
| == | Equal to |
| != | Not equal to |

* Arithmetic and relational operators work on vectors.

**Logical** operators allow us to carry out boolean operations:

| Operator | Description |
|---|:---|
| ! | Not |
| \| | Or (element_wise) |
| & | And (element-wise) |
| \|\| | Or |
| && | And |

* The difference between `|` and `||` is that `||` evaluates only the first 
element of the two vectors, whereas `|` evaluates element-wise. 

### Demonstration

Continue along with the worksheet. 

## `summarize()` (3 min)

Like `mutate()`, the `summarize()` function also creates new columns, but the calculations that make the new columns must reduce down to a single number. 

For example, let's compute the mean and standard deviation of life expectancy in the gapminder data set:

```{r}
gapminder %>% 
  summarize(mu    = mean(lifeExp),
            sigma = sd(lifeExp))
```

Notice that all other columns were dropped. This is necessary, because there's no obvious way to compress the other columns down to a single row. This is unlike `mutate()`, which keeps all columns, and more like `transmute()`, which drops all other columns.

As it is, this is hardly useful. But that's outside of the context of _grouping_, coming up next.

## `group_by()` (20 min)

The true power of `dplyr` lies in its ability to group a tibble, with the `group_by()` function. As usual, this function takes in a tibble and returns a (grouped) tibble. 

Let's group the gapminder dataset by continent and year:

```{r}
gapminder %>% 
  group_by(continent, year)
```

The only thing different from a regular tibble is the indication of grouping variables above the tibble. This means that the tibble is recognized as having "chunks" defined by unique combinations of continent and year:

- Asia in 1952 is one chunk.
- Asia in 1957 is another chunk.
- Europe in 1952 is another chunk.
- etc...

Notice that the data frame isn't rearranged by chunk! 

Now that the tibble is grouped, operations that you do on a grouped tibble _will be done independently within each chunk_, as if no other chunks exist. 

You can also create new variables and group by that variable simultaneously. Try splitting life expectancy by "small" and "large" using 60 as a threshold:

```{r}
gapminder %>% 
  group_by(smallLifeExp = lifeExp < 60)
```


### Grouped `summarize()` (10 min)

Want to compute the mean and standard deviation for each year for every continent? No problem:

```{r}
gapminder %>% 
  group_by(continent, year) %>% 
  summarize(mu    = mean(lifeExp),
            sigma = sd(lifeExp))
```

Notice:

- The grouping variables are kept in the tibble, because their values are unique within in chunk (by definition of the chunk!)
- With each call to `summarize()`, the grouping variables are "peeled back" from last grouping variable to first.

This means the above tibble is now only grouped by continent. What happens when we reverse the grouping?

```{r}
gapminder %>% 
  group_by(year, continent) %>%    # Different order
  summarize(mu    = mean(lifeExp),
            sigma = sd(lifeExp))
```

The grouping columns are switched, and now the tibble is grouped by year instead of continent. 

`dplyr` has a bunch of convenience functions that help us write code more eloquently. We could use `group_by()` and `summarize()` with `length()` to find the number of entries each country has:

```{r}
gapminder %>% 
  group_by(country) %>% 
  transmute(n = length(country))
```

Or, we can use `dplyr::n()` to count the number of rows in each group:

```{r}
gapminder %>% 
  group_by(country) %>% 
  summarize(n = n())
```

Or better yet, just use `dplyr::count()`:

```{r}
gapminder %>% 
  count(country)
```

### Grouped `mutate()` (3 min)

Want to get the increase in GDP per capita for each country? No problem:

```{r}
gap_inc <- gapminder %>% 
  arrange(year) %>% 
  group_by(country) %>%
  mutate(gdpPercap_inc = gdpPercap - lag(gdpPercap))
DT::datatable(gap_inc)
```

You can't see it here (because of the `datatable()` output), but the tibble is still grouped by country.

Drop the `NA`s with another convenience function, this time supplied by the `tidyr` package (another tidyverse package that we'll see soon):

```{r}
gap_inc %>% 
  tidyr::drop_na()
```

## Function types (5 min)

We've seen cases of transforming variables using `mutate()` and `summarize()`, both with and without `group_by()`. How can you know what combination to use? Here's a summary based on one of three types of functions.


| Function type | Explanation | Examples | In `dplyr` |
|------|-----|----|----|
| Vectorized functions | These take a vector, and operate on each component independently to return a vector of the same length. In other words, they work element-wise. | `cos()`, `sin()`, `log()`, `exp()`, `round()` | `mutate()` |
| Aggregate functions | These take a vector, and return a vector of length 1 | `mean()`, `sd()`, `length()` | `summarize()`, esp with `group_by()`. |
| Window Functions | these take a vector, and return a vector of the same length that depends on the vector as a whole. | `lag()`, `rank()`, `cumsum()` | `mutate()`, esp with `group_by()` |

## `dplyr` Exercises (20 min)

## Dates and Times (5 min)

The `lubridate` package is great for identifying dates and times. You can also do arithmetic with dates and times with the package, but we won't be discussing that.

Make an object of class `"Date"` using a function that's some permutation of `y`, `m`, and `d` (for year, month, and date, respectively). These functions are more flexible than your yoga instructor:

```{r}
lubridate::mdy("September 24, 2019")
lubridate::mdy("Sep 24 2019")
lubridate::mdy("9-24-19")
lubridate::dym(c("24-2019, September", "25 2019 Sep"))
```

Notice that they display the dates all in `ymd` format, which is best for computing because the dates sort nicely this way.

This is not just a character!

```{r}
lubridate::ymd("2019 September 24") %>% 
  class()
```

You can tag on `hms`, too:

```{r}
lubridate::ymd_hms("2019 September 24, 23:59:59")
```

We can also extract information from these objects. Day of the week:

```{r}
today <- lubridate::ymd("2019 September 24")
lubridate::wday(today, label = TRUE)
```

Day:

```{r}
lubridate::day(today)
```

Number of days into the year:

```{r}
lubridate::yday(today)
```

Is it a leap year this year?

```{r}
lubridate::leap_year(today)
```

The newer `tsibble` package gives these `lubridate` functions some friends. What's the year and month? Year and week?

```{r}
tsibble::yearmonth(today)
tsibble::yearweek(today)
```


## Tsibbles (15 min)

A `tsibble` (from the package of the same name) is a special type of `tibble`, useful for handling data where a column indicates a time variable.

As an example, here are daily records of a household's electricity usage:

```{r}
energy <- here::here("data", "daily_consumption.csv") %>% 
  read_csv()
energy
```

Let's make this a `tsibble` in the same way we'd convert a data frame to a `tibble`: with the `as_tsibble()` function. The conversion requires you to specify which column contains the time index, using the `index` argument.

```{r}
(energy <- as_tsibble(energy, index = date))
```

We already see an improvement vis-a-vis the sorted dates!

This is an example of _time series_ data, because the time interval has a regular spacing. A `tsibble` cleverly determines and stores this interval. With the energy consumption data, the interval is one day ("1D" means "1 day", not "1 dimension"!):

```{r}
interval(energy)
```

Notice that there is no record for December 21, 2006, in what would be Row 5. Such records are called _implicit NA's_, because they're actually missing, but aren't explicitly shown as missing in your data set. If you don't make these explicit, you could mess up your analysis if it's anticipating your data to be equally spaced in time. Just `full_gaps()` to bring them out of hiding:


```{r}
(energy <- fill_gaps(energy))
```

Already, it's better to plot the data now that these gaps are filled in. Let's check out 2010. See how the plot without NA's can be a little misleading? Moral: always be as honest as possible with your data.

```{r}
small_energy <- filter(energy, year(date) == 2010)
cowplot::plot_grid(
  ggplot(small_energy, aes(date, intensity)) +
    geom_line() +
    theme_bw() +
    xlab("Date (in 2010)") +
    ggtitle("NA's made explicit"),
  ggplot(drop_na(small_energy), aes(date, intensity)) +
    geom_line() +
    theme_bw() +
    xlab("Date (in 2010)") +
    ggtitle("NA's in hiding (implicit)"),
  nrow = 2
)
```

How would we convert `gapminder` to a `tsibble`, since it has a time series per country? Use the `key` argument to specify the grouping:

```{r}
gapminder %>% 
  as_tsibble(index = year, key = country)
```



### `index_by()` instead of `group_by()` (5 min)

It looks like there's seasonality in intensity across the year:

```{r}
ggplot(energy, aes(yday(date), intensity)) +
  geom_point() +
  theme_bw() +
  labs(x = "Day of the Year")
```

Let's get a mean estimate of intensity on each day of the year. We'd like to `group_by(yday(date))`, but because we're grouping on the index variable, we use `index_by()` instead. 

```{r}
energy %>% 
  tsibble::index_by(day_of_year = yday(date)) %>% 
  dplyr::summarize(mean_intensity = mean(intensity, na.rm = TRUE))
```

What if we wanted to make the time series less granular? Instead of total daily consumption, how about total weekly consumption? Note the convenience function `summarize_all()` given to us by `dplyr`!

```{r}
energy %>% 
  tsibble::index_by(yearweek = yearweek(date)) %>% 
  dplyr::summarize_all(sum)
```

By the way, there's no need to worry about "truncated weeks" at the beginning and end of the year. For example, December 31, 2019 is a Tuesday, and is Week 53, but its "yearmonth" is Week 1 in 2020:

```{r}
dec31 <- "2019-12-31"
wday(dec31, label = TRUE)
week(dec31)
yearweek(dec31)
```


## Time remaining?

If so, let's make tibbles with `tibble()`, and make a list column while we're at it. Maybe even `nest()` and `unnest()`.

## If there's time remaining

1. Let's do the bonus exercises together, in the `cm006-exercise.Rmd` file.
2. Another "break"

## Participation repository and GitHub Pages

### GitHub Pages

You can turn your GitHub repository into a website, by enabling __GitHub Pages__ on that repo. This is useful for something as small as being able to display HTML files without getting a local copy of the repository, to something as big as making a full fledged website like the [stat545.stat.ubc.ca](https://stat545.stat.ubc.ca) website. 

- If you make a repo called `yourusername.github.io`, and enable GitHub Pages on that repo, then the URL of the website will be `https://yourusername.github.io/`.
- If you enable GitHub pages on any other repo, the URL for that repo will be `https://yourusername.github.io/name_of_other_repo`.

Learn more with GitHub's [GitHub Pages](https://pages.github.com/) tutorial. 

### Practice with HTML file linking

We'll practice linking to an HTML file for today's exercise, by following the instructions on the (new!) ["Viewing and Linking to HTML Files"](https://stat545.stat.ubc.ca/evaluation/assignments/#viewing-and-linking-to-html-files) on the assignments home page.

