---
title: 's12: Simulation Exercise'
output: 
  html_document:
    keep_md: true
    theme: paper
---

<!---The following chunk allows errors when knitting--->

```{r allow errors, echo = FALSE}
knitr::opts_chunk$set(error = TRUE)

#Sets our seed
set.seed(9999)
```

# Intro to simulations in R

Load the `tidyverse` package.
    - This will mainly be used for ggplot, but some of the data manipulation tools may be useful.

```{r load packages, warning = FALSE, message = FALSE}
# load your packages here:
library(FILL_THIS_IN)
```
    

## `rnorm()`

1. Simulate two datasets that follow a normal distribution. The first one should have a mean of 4 and SD of 1. The second one should have a mean of 8 and SD of 1.5. Both should have 200 cases.

```{r}
dataNormal1 <- as.data.frame(rnorm(FILL_THIS_IN))
dataNormal2 <- as.data.frame(rnorm(FILL_THIS_IN))

#Converts the name of your column containing the data to "Values".
names(dataNormal1) <- "Values"
names(dataNormal2) <- "Values"
```

2. Create a group factor so you know which dataset a number comes from, then combine the two datasets.

```{r}
#Using brackets [] allows us to create a new column in our dataframe
dataNormal1[1:200,"Group"] <- "Group1"
dataNormal2[1:200,"Group"]<- "Group2"

dataNormalCombined <- rbind(FILL_THIS_IN)
```

3. Graph these distributions using GGplot.

```{r}
ggplot(FILL_THIS_IN) +
  geom_histogram(alpha=0.6, position = 'identity')
```

4. Run summary stats 

```{r}
summary(FILL_THIS_IN)
summary(FILL_THIS_IN)
summary(FILL_THIS_IN)
```

5. Run a t-test on your data

```{r}
t.test(dataNormalCombined$Values~dataNormalCombined$Group)
```
### Back to guide

## `sample()`

1. Sample from 5 numbers that follow an inverted normal distribution. (i.e. the probabilities are highest at the end points and lowest in the center).

```{r}

sample(c(FILL_THIS_IN), 200, replace=T, prob = c(FILL_THIS_IN)) 
hist(FILL_THIS_IN)

```

2. Pick one of the distributions that are [built into R](https://www.stat.umn.edu/geyer/old/5101/rlook.html) and replicate that distribution with the sample function. Make sure you graph both the original distribution and the reproduced distribution so you can make sure they match.

```{r}
#Add code for your initial distribution here. Make sure to use rDistributionFunction so that random numbers are generated.
FILL_THIS_IN
hist(FILL_THIS_IN)

#Replicate your distribution with the sample function.
sample(c(seq(FILL_THIS_IN)), #scale points
       10000, replace=T, prob = c(FILL_THIS_IN)) 
hist(FILL_THIS_IN)
```

### Back to guide

## ``for()`

1. Create a loop that generates a number from your favorite distribution and writes it to a column of your matrix. The matrix should have 20 rows and 1 column. You can use one of the distribution functions built into R, or create your own using `sample()`.
```{r}
matrix(FILL_THIS_IN)

for(FILL_THIS_IN)
{
  FILL_THIS_IN
}
hist(FILL_THIS_IN)
```

2. Write a loop within a loop. First, create a matrix with 20 rows and 6 columns. Save a number from your favorite distribution into each cell of the matrix. You can use one of the distribution functions built into R, or create your own using `sample()`. The distribution of responses should be the same for every person.

```{r}
matrix(FILL_THIS_IN)

for(FILL_THIS_IN)
{
  for (FILL_THIS_IN)
  {
   FILL_THIS_IN
  }
}

hist(FILL_THIS_IN)
```

3. Repeat 2, but this time make your distribution centered within each person.

```{r}
matrix(FILL_THIS_IN)

for(FILL_THIS_IN)
  {
  for(FILL_THIS_IN)
    {    
    if(FILL_THIS_IN
       {
         FILL_THIS_IN
       }
    else
      {
        FILL_THIS_IN
      }
    }
  }

hist(FILL_THIS_IN)
```

3. If needed, replace any out-of-bounds data.
```{r}
FILL_THIS_IN

hist(FILL_THIS_IN)
```
